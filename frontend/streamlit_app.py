#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
===============================================
Copiloto Conversacional - Frontend Interface
===============================================
Copyright (c) 2025 Cristian Soto
Desarrollado como prueba t√©cnica

Uso comercial requiere licencia separada.
Ver LICENSE para t√©rminos completos.
Contacto: https://github.com/Cristian-Soto
===============================================
"""

import streamlit as st
import requests
import json
from typing import Optional

# Configuraci√≥n de p√°gina - DEBE ser lo primero
st.set_page_config(
    page_title="Copiloto Conversacional",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# CSS personalizado
st.markdown("""
<style>
    /* TEMA OSCURO COMPLETO */
    
    /* Configuraci√≥n del body y elementos ra√≠z */
    .main {
        padding-top: 2rem;
        background: linear-gradient(135deg, #0f1419 0%, #1a1d23 50%, #0f1419 100%);
        color: #e0e6ed;
    }
    
    /* Forzar modo oscuro en toda la aplicaci√≥n */
    .stApp {
        background: linear-gradient(135deg, #0f1419 0%, #1a1d23 50%, #0f1419 100%);
        color: #e0e6ed;
    }
    
    /* Header moderno oscuro */
    .main-header {
        text-align: center;
        padding: 3rem 2rem;
        background: linear-gradient(135deg, #1e2328 0%, #2d3339 100%);
        border-radius: 20px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(102, 126, 234, 0.2);
        color: #e0e6ed;
    }
    
    /* Chat container oscuro */
    .chat-container {
        background: linear-gradient(135deg, #1e2328 0%, #2d3339 100%);
        border-radius: 20px;
        padding: 2rem;
        box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        margin-bottom: 2rem;
        max-width: 800px;
        margin-left: auto;
        margin-right: auto;
        border: 1px solid rgba(102, 126, 234, 0.2);
        color: #e0e6ed;
    }
    
    /* Mensajes de chat oscuros */
    .user-message {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 20px 20px 5px 20px;
        margin: 1rem 0;
        max-width: 80%;
        margin-left: auto;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    
    .ai-message {
        background: linear-gradient(135deg, #2d3339 0%, #3d444d 100%);
        color: #e0e6ed;
        padding: 1rem 1.5rem;
        border-radius: 20px 20px 20px 5px;
        margin: 1rem 0;
        max-width: 80%;
        margin-right: auto;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        border: 1px solid rgba(102, 126, 234, 0.2);
    }
    
    /* Sidebar oscuro */
    .css-1d391kg {
        background: linear-gradient(180deg, #0f1419 0%, #1a1d23 100%);
        color: #e0e6ed;
    }
    
    /* Botones modernos oscuros */
    .stButton > button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 25px;
        padding: 0.6rem 2rem;
        font-weight: 600;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        transition: all 0.3s ease;
    }
    
    .stButton > button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        background: linear-gradient(135deg, #7c8ef7 0%, #8a5bb8 100%);
    }
    
    /* Input de texto oscuro */
    .stTextInput > div > div > input,
    .stTextArea > div > div > textarea {
        background: linear-gradient(135deg, #2d3339 0%, #3d444d 100%) !important;
        border: 2px solid rgba(102, 126, 234, 0.3) !important;
        border-radius: 15px !important;
        padding: 15px 20px !important;
        font-size: 16px !important;
        transition: all 0.3s ease !important;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2) !important;
        color: #e0e6ed !important;
    }
    
    .stTextInput > div > div > input:focus,
    .stTextArea > div > div > textarea:focus {
        border-color: #667eea !important;
        box-shadow: 0 0 20px rgba(102, 126, 234, 0.4) !important;
        transform: scale(1.02) !important;
        outline: none !important;
        background: linear-gradient(135deg, #3d444d 0%, #4d545d 100%) !important;
    }
    
    .stTextInput > div > div > input::placeholder,
    .stTextArea > div > div > textarea::placeholder {
        color: #8a9ba8 !important;
        font-style: italic !important;
    }
    
    /* Selectbox oscuro */
    .stSelectbox > div > div > select {
        background: linear-gradient(135deg, #2d3339 0%, #3d444d 100%) !important;
        color: #e0e6ed !important;
        border: 2px solid rgba(102, 126, 234, 0.3) !important;
        border-radius: 15px !important;
    }
    
    /* Slider oscuro */
    .stSlider > div > div > div > div {
        background: #667eea !important;
    }
    
    .stSlider > div > div > div {
        background: #2d3339 !important;
    }
    
    /* M√©tricas oscuras */
    .metric-value {
        color: #e0e6ed !important;
    }
    
    .metric-delta {
        color: #8a9ba8 !important;
    }
    
    /* Expanders oscuros */
    .streamlit-expanderHeader {
        background: linear-gradient(90deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2)) !important;
        border-radius: 10px !important;
        transition: all 0.3s ease !important;
        color: #e0e6ed !important;
        border: 1px solid rgba(102, 126, 234, 0.2) !important;
    }
    
    .streamlit-expanderHeader:hover {
        background: linear-gradient(90deg, rgba(102, 126, 234, 0.3), rgba(118, 75, 162, 0.3)) !important;
        transform: scale(1.01) !important;
    }
    
    .streamlit-expanderContent {
        background: linear-gradient(135deg, #1e2328 0%, #2d3339 100%) !important;
        border: 1px solid rgba(102, 126, 234, 0.2) !important;
        border-radius: 0 0 10px 10px !important;
        color: #e0e6ed !important;
    }
    
    /* Tabs oscuras */
    .stTabs [data-baseweb="tab-list"] {
        background: linear-gradient(135deg, #1e2328 0%, #2d3339 100%);
        border-radius: 15px;
        padding: 0.5rem;
        border: 1px solid rgba(102, 126, 234, 0.2);
    }
    
    .stTabs [data-baseweb="tab"] {
        background: transparent;
        color: #8a9ba8;
        border-radius: 10px;
        padding: 0.8rem 1.5rem;
        font-weight: 600;
        transition: all 0.3s ease;
    }
    
    .stTabs [aria-selected="true"] {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }
    
    /* Contenido de tabs oscuro */
    .stTabs > div[data-baseweb="tab-panel"] {
        background: linear-gradient(135deg, #1e2328 0%, #2d3339 100%);
        border-radius: 15px;
        padding: 2rem;
        margin-top: 1rem;
        border: 1px solid rgba(102, 126, 234, 0.2);
        color: #e0e6ed;
    }
    
    /* File uploader oscuro */
    .stFileUploader > div {
        background: linear-gradient(135deg, #2d3339 0%, #3d444d 100%) !important;
        border: 2px dashed rgba(102, 126, 234, 0.3) !important;
        border-radius: 15px !important;
        color: #e0e6ed !important;
    }
    
    /* Columnas oscuras */
    .element-container {
        animation: fadeInUp 0.6s ease-out;
    }
    
    /* Spinner oscuro */
    .stSpinner > div {
        border-color: #667eea !important;
    }
    
    /* Alertas oscuras */
    .stAlert {
        background: linear-gradient(135deg, #2d3339 0%, #3d444d 100%) !important;
        border: 1px solid rgba(102, 126, 234, 0.3) !important;
        color: #e0e6ed !important;
    }
    
    /* Status indicators oscuros */
    .status-online {
        color: #4ade80;
        font-weight: 600;
        text-shadow: 0 0 10px rgba(74, 222, 128, 0.3);
    }
    
    .status-offline {
        color: #f87171;
        font-weight: 600;
        text-shadow: 0 0 10px rgba(248, 113, 113, 0.3);
    }
    
    /* Animaciones */
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(-20px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }
    
    /* Texto general oscuro */
    h1, h2, h3, h4, h5, h6, p, div, span, label {
        color: #e0e6ed !important;
    }
    
    /* Markdown oscuro */
    .markdown-text-container {
        color: #e0e6ed !important;
    }
    
    /* Caption oscuro */
    .caption {
        color: #8a9ba8 !important;
    }
    
    /* Form submit button oscuro */
    .stFormSubmitButton > button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        color: white !important;
        border: none !important;
        border-radius: 15px !important;
        padding: 0.8rem 2rem !important;
        font-weight: 600 !important;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3) !important;
        transition: all 0.3s ease !important;
    }
    
    .stFormSubmitButton > button:hover {
        transform: translateY(-2px) !important;
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5) !important;
        background: linear-gradient(135deg, #7c8ef7 0%, #8a5bb8 100%) !important;
    }
    
    /* Efectos adicionales para modo oscuro */
    .fade-in {
        animation: fadeInUp 0.8s ease-out;
    }
    
    /* Cards de documentos oscuras */
    .document-card {
        background: linear-gradient(135deg, #1e2328 0%, #2d3339 100%) !important;
        border: 1px solid rgba(102, 126, 234, 0.2) !important;
        color: #e0e6ed !important;
        transition: all 0.3s ease !important;
    }
    
    .document-card:hover {
        transform: translateY(-3px) !important;
        box-shadow: 0 12px 30px rgba(0,0,0,0.4) !important;
        border-color: rgba(102, 126, 234, 0.4) !important;
    }
</style>
""", unsafe_allow_html=True)

# Configuraci√≥n de la API
API_BASE_URL = "http://backend:8000"

def send_document_to_api(uploaded_file) -> Optional[dict]:
    """
    Env√≠a un documento PDF al backend para su procesamiento.
    
    Args:
        uploaded_file: Archivo subido desde Streamlit
        
    Returns:
        dict: Respuesta del backend o None si hay error
    """
    try:
        files = {"uploaded_file": (uploaded_file.name, uploaded_file, "application/pdf")}
        response = requests.post(f"{API_BASE_URL}/upload", files=files)
        
        if response.status_code == 200:
            return response.json()
        else:
            st.error(f"Error del servidor: {response.status_code}")
            return None
    except requests.exceptions.ConnectionError:
        st.error("No se puede conectar al backend. Verifica que los servicios est√©n ejecut√°ndose.")
        return None
    except Exception as e:
        st.error(f"Error inesperado: {str(e)}")
        return None

def main():
    # Watermark de evaluaci√≥n (reducido)
    st.markdown("""
    <div style="position: fixed; top: 10px; right: 10px; background: rgba(102, 126, 234, 0.9); 
                color: white; padding: 6px 12px; border-radius: 15px; z-index: 1000; 
                font-size: 11px; font-weight: 600; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
        üìã Evaluaci√≥n T√©cnica
    </div>
    """, unsafe_allow_html=True)

    st.markdown("""
    <div class="main-header fade-in">
        <p style="font-size: 1.4rem; color: #8a9ba8; margin-top: 1rem; font-weight: 400; line-height: 1.3;">
            Copiloto Conversacional
        </p>
        <p style="font-size: 1rem; color: #8a9ba8; margin-top: 1.2rem; font-style: italic; opacity: 0.8;">
            üí° Desarrollado por Cristian Soto como prueba t√©cnica ‚Ä¢ ¬© 2025
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Navegaci√≥n moderna con tabs
    tab1, tab2, tab3 = st.tabs(["üí¨ Chat Inteligente", "üìÑ Mis Documentos", "üî¨ An√°lisis Avanzado"])
    
    with tab1:
        modern_chat_page()
    
    with tab2:
        modern_documents_page()
        
    with tab3:
        modern_analysis_page()

def modern_chat_page():
    
    # Verificar estado del sistema
    system_status = get_system_status()
    
    # Contenedor principal del chat
    #st.markdown('<div class="chat-container fade-in">', unsafe_allow_html=True)
    
    # Status bar moderno
    col_status1, col_status2, col_status3 = st.columns(3)
    
    with col_status1:
        if system_status.get("ai_online", False):
            st.markdown('<p class="status-online">üü¢ IA Local Activa</p>', unsafe_allow_html=True)
        else:
            st.markdown('<p class="status-offline">üî¥ IA Local Desconectada</p>', unsafe_allow_html=True)
    
    with col_status2:
        total_docs = system_status.get("total_documents", 0)
        st.markdown(f'<p style="font-weight: 600; color: #667eea;">üìö {total_docs} documentos</p>', unsafe_allow_html=True)
    
    with col_status3:
        total_fragments = system_status.get("total_fragments", 0)
        st.markdown(f'<p style="font-weight: 600; color: #f093fb;">üß© {total_fragments} fragmentos</p>', unsafe_allow_html=True)
    
    st.markdown("---")
    
    # Upload area moderna
    st.markdown("### üì§ Subir Nuevo Documento")
    
    uploaded_file = st.file_uploader(
        "",
        type=['pdf'],
        help="Arrastra tu PDF aqu√≠ o haz clic para seleccionar",
        label_visibility="collapsed"
    )
    
    if uploaded_file is not None:
        st.markdown("""
        <div class="upload-area">
            <h4 style="color: #667eea; margin: 0;">‚ú® Archivo Listo para Procesar</h4>
        </div>
        """, unsafe_allow_html=True)
        
        col_upload1, col_upload2 = st.columns([2, 1])
        
        with col_upload1:
            st.write(f"ÔøΩ **{uploaded_file.name}**")
            st.write(f"üìä Tama√±o: {uploaded_file.size / 1024:.1f} KB")
        
        with col_upload2:
            if st.button("ÔøΩ Procesar Documento", type="primary", use_container_width=True):
                process_uploaded_document(uploaded_file)
    
    st.markdown("---")
    
    # Chat area moderno con IA
    st.markdown("### Conversaci√≥n con IA")
    
    # Configuraci√≥n avanzada colapsable
    with st.expander("‚öôÔ∏è Configuraci√≥n Avanzada", expanded=False):
        col_config1, col_config2 = st.columns(2)
        
        with col_config1:
            max_results = st.slider("üìÑ Documentos relevantes", 1, 10, 7, key="modern_max_results")
        
        with col_config2:
            similarity_threshold = st.slider("üéØ Precisi√≥n de b√∫squeda", 0.1, 1.0, 0.3, 0.1, key="modern_similarity")
    
    # Inicializar historial de chat
    if "modern_chat_history" not in st.session_state:
        st.session_state.modern_chat_history = []
    
    # Mostrar historial de chat con dise√±o moderno
    chat_history_container = st.container()
    
    with chat_history_container:
        for message in st.session_state.modern_chat_history:
            if message["role"] == "user":
                st.markdown(f"""
                <div class="user-message">
                    <strong>üôã‚Äç‚ôÇÔ∏è T√∫:</strong><br>
                    {message['content']}
                </div>
                """, unsafe_allow_html=True)
            else:
                ai_icon = "ü§ñ" if message.get("llm_used") == "ollama_direct" else "ÔøΩ"
                st.markdown(f"""
                <div class="ai-message">
                    <strong>{ai_icon} IA:</strong><br>
                    {message['content']}
                </div>
                """, unsafe_allow_html=True)
                
                # Mostrar documentos consultados
                if message.get("documents"):
                    with st.expander(f"ÔøΩ {len(message['documents'])} documentos consultados", expanded=False):
                        for doc in message["documents"][:3]:
                            st.caption(f"üìÑ {doc.get('filename', 'Sin nombre')} (relevancia: {doc.get('similarity_score', 0):.2f})")
    
    # Input moderno para nuevos mensajes
    st.markdown("---")
    
    # √Årea de input moderna
    # √Årea de input moderna con formulario (evita error de st.chat_input en contenedores)
    with st.form(key="chat_form_modern", clear_on_submit=True):
        user_input = st.text_area(
            "üí≠ Escribe tu pregunta aqu√≠:",
            placeholder="Pregunta sobre tus documentos...",
            height=100,
            help="Escribe tu pregunta y presiona el bot√≥n para enviar"
        )
        submit_button = st.form_submit_button("üöÄ Enviar Mensaje", type="primary", use_container_width=True)
    
    if submit_button and user_input:
        # Agregar mensaje del usuario
        st.session_state.modern_chat_history.append({
            "role": "user",
            "content": user_input
        })
        
        # Procesar respuesta
        with st.spinner("ü§î IA est√° pensando..."):
            ai_response = process_chat_query(user_input, max_results, similarity_threshold)
            
            if ai_response:
                st.session_state.modern_chat_history.append(ai_response)
        
        st.rerun()
    
    # Botones de acci√≥n
    col_action1, col_action2, col_action3 = st.columns(3)
    
    with col_action1:
        if st.button("üóëÔ∏è Limpiar Chat", use_container_width=True):
            st.session_state.modern_chat_history = []
            st.rerun()
    
    with col_action2:
        if st.button("üìÑ Resumir Conversaci√≥n", use_container_width=True):
            if st.session_state.modern_chat_history:
                generate_conversation_summary()
    
    with col_action3:
        if st.button("üíæ Exportar Chat", use_container_width=True):
            if st.session_state.modern_chat_history:
                export_chat_history()
    
    st.markdown('</div>', unsafe_allow_html=True)

def get_system_status():
    """Obtiene el estado del sistema de manera simplificada"""
    try:
        response = requests.get(f"{API_BASE_URL}/api/chat/status", timeout=5)
        if response.status_code == 200:
            data = response.json()
            
            # Obtener informaci√≥n de documentos
            docs_response = requests.get(f"{API_BASE_URL}/api/chat/documents", timeout=5)
            docs_data = {}
            if docs_response.status_code == 200:
                docs_data = docs_response.json()
            
            return {
                "ai_online": data.get("llm_service", {}).get("ollama_connected", False),
                "total_documents": docs_data.get("total_documents", 0),
                "total_fragments": docs_data.get("total_fragments", 0),
                "vector_db_connected": data.get("vector_database", {}).get("connected", False)
            }
    except:
        pass
    
    return {
        "ai_online": False,
        "total_documents": 0,
        "total_fragments": 0,
        "vector_db_connected": False
    }

def process_uploaded_document(uploaded_file):
    """Procesa un documento subido con interfaz moderna"""
    try:
        with st.spinner("üöÄ Procesando documento..."):
            result = send_document_to_api(uploaded_file)
            
            if result:
                st.success("‚úÖ ¬°Documento procesado exitosamente!")
                
                # Estad√≠sticas en cards modernas
                doc_stats = result.get('document_stats', {})
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.markdown(f"""
                    <div class="metric-card">
                        <h3 style="color: #667eea; margin: 0;">üìÑ</h3>
                        <p style="font-size: 1.5rem; font-weight: bold; margin: 0;">{doc_stats.get('total_pages', 0)}</p>
                        <p style="color: #666; margin: 0;">P√°ginas</p>
                    </div>
                    """, unsafe_allow_html=True)
                
                with col2:
                    st.markdown(f"""
                    <div class="metric-card">
                        <h3 style="color: #f093fb; margin: 0;">üß©</h3>
                        <p style="font-size: 1.5rem; font-weight: bold; margin: 0;">{doc_stats.get('fragments_count', 0)}</p>
                        <p style="color: #666; margin: 0;">Fragmentos</p>
                    </div>
                    """, unsafe_allow_html=True)
                
                with col3:
                    st.markdown(f"""
                    <div class="metric-card">
                        <h3 style="color: #27ae60; margin: 0;">üìè</h3>
                        <p style="font-size: 1.5rem; font-weight: bold; margin: 0;">{doc_stats.get('text_length', 0):,}</p>
                        <p style="color: #666; margin: 0;">Caracteres</p>
                    </div>
                    """, unsafe_allow_html=True)
            else:
                st.error("‚ùå Error procesando el archivo")
                
    except Exception as e:
        st.error(f"‚ùå Error: {str(e)}")

def process_chat_query(question, max_results, similarity_threshold):
    """Procesa una consulta de chat y retorna la respuesta"""
    try:
        response = requests.post(
            f"{API_BASE_URL}/api/chat/chat",
            json={
                "question": question,
                "max_results": max_results,
                "similarity_threshold": similarity_threshold
            },
            timeout=30
        )
        
        if response.status_code == 200:
            result = response.json()
            return {
                "role": "assistant",
                "content": result.get("answer", "No pude generar una respuesta."),
                "documents": result.get("relevant_documents", []),
                "confidence": result.get("confidence_score", 0),
                "llm_used": result.get("llm_used", "unknown")
            }
        else:
            return {
                "role": "assistant",
                "content": f"‚ùå Error del servidor: {response.status_code}",
                "documents": [],
                "confidence": 0,
                "llm_used": "error"
            }
            
    except requests.exceptions.Timeout:
        return {
            "role": "assistant", 
            "content": "‚è∞ La consulta est√° tomando m√°s tiempo del esperado",
            "documents": [],
            "confidence": 0,
            "llm_used": "timeout"
        }
    except Exception as e:
        return {
            "role": "assistant",
            "content": f"‚ùå Error: {str(e)}",
            "documents": [],
            "confidence": 0,
            "llm_used": "error"
        }

def generate_conversation_summary():
    """Genera un resumen de la conversaci√≥n"""
    if not st.session_state.modern_chat_history:
        st.info("No hay conversaci√≥n para resumir")
        return
    
    # Combinar todas las preguntas y respuestas
    chat_text = "\n\n".join([
        f"{'Usuario' if msg['role'] == 'user' else 'IA'}: {msg['content']}"
        for msg in st.session_state.modern_chat_history
    ])
    
    st.markdown("### üìÑ Resumen de la Conversaci√≥n")
    st.text_area("", chat_text, height=300, key="conversation_summary")

def export_chat_history():
    """Exporta el historial de chat"""
    if not st.session_state.modern_chat_history:
        st.info("No hay conversaci√≥n para exportar")
        return
    
    # Crear archivo de exportaci√≥n
    chat_export = {
        "timestamp": str(st.session_state.get('chat_timestamp', '')),
        "messages": st.session_state.modern_chat_history,
        "total_messages": len(st.session_state.modern_chat_history)
    }
    
    st.download_button(
        label="‚¨áÔ∏è Descargar Conversaci√≥n",
        data=json.dumps(chat_export, indent=2, ensure_ascii=False),
        file_name=f"conversacion_{len(st.session_state.modern_chat_history)}_mensajes.json",
        mime="application/json"
    )

def modern_documents_page():
    """P√°gina moderna para gesti√≥n de documentos"""
    st.markdown('<div class="chat-container fade-in">', unsafe_allow_html=True)
    
    st.markdown("### üìö Gesti√≥n de Documentos")
    
    # Obtener documentos
    try:
        response = requests.get(f"{API_BASE_URL}/api/chat/documents", timeout=10)
        if response.status_code == 200:
            docs_data = response.json()
            if docs_data.get('success', False):
                documents = docs_data.get('documents', [])
                
                # Estad√≠sticas generales con cards modernas
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.markdown(f"""
                    <div class="metric-card">
                        <h3 style="color: #667eea; margin: 0;">üìÑ</h3>
                        <p style="font-size: 2rem; font-weight: bold; margin: 0;">{len(documents)}</p>
                        <p style="color: #666; margin: 0;">Documentos</p>
                    </div>
                    """, unsafe_allow_html=True)
                
                with col2:
                    total_fragments = docs_data.get('total_fragments', 0)
                    st.markdown(f"""
                    <div class="metric-card">
                        <h3 style="color: #f093fb; margin: 0;">üß©</h3>
                        <p style="font-size: 2rem; font-weight: bold; margin: 0;">{total_fragments}</p>
                        <p style="color: #666; margin: 0;">Fragmentos</p>
                    </div>
                    """, unsafe_allow_html=True)
                
                with col3:
                    avg_fragments = round(total_fragments / len(documents), 1) if documents else 0
                    st.markdown(f"""
                    <div class="metric-card">
                        <h3 style="color: #27ae60; margin: 0;">üìä</h3>
                        <p style="font-size: 2rem; font-weight: bold; margin: 0;">{avg_fragments}</p>
                        <p style="color: #666; margin: 0;">Promedio</p>
                    </div>
                    """, unsafe_allow_html=True)
                
                st.markdown("---")
                
                # Lista de documentos con dise√±o moderno
                if documents:
                    for i, doc in enumerate(documents):
                        st.markdown(f"""
                        <div class="doc-card">
                            <h4 style="color: #667eea; margin: 0 0 0.5rem 0;">üìÑ {doc.get('filename', 'Sin nombre')}</h4>
                            <p style="color: #666; margin: 0.2rem 0;"><strong>P√°ginas:</strong> {doc.get('total_pages', 0)} | <strong>Fragmentos:</strong> {doc.get('fragment_count', 0)}</p>
                            <p style="color: #888; font-size: 0.9rem; margin: 0.5rem 0;">{doc.get('content_preview', '')}</p>
                        </div>
                        """, unsafe_allow_html=True)
                        
                        # Botones de acci√≥n
                        col_action1, col_action2, col_action3, col_action4 = st.columns(4)
                        
                        with col_action1:
                            if st.button("üîç Ver", key=f"view_{i}", use_container_width=True):
                                st.session_state[f'view_doc_{i}'] = True
                        
                        with col_action2:
                            if st.button("üìù Resumir", key=f"summarize_{i}", use_container_width=True):
                                st.info("üöß Funci√≥n en desarrollo")
                        
                        with col_action3:
                            if st.button("üîç Buscar", key=f"search_{i}", use_container_width=True):
                                st.info("üöß Funci√≥n en desarrollo")
                        
                        with col_action4:
                            if st.button("üóëÔ∏è Eliminar", key=f"delete_{i}", use_container_width=True):
                                st.session_state[f'delete_doc_{i}'] = True
                        
                        # Manejo de eliminaci√≥n
                        if st.session_state.get(f'delete_doc_{i}', False):
                            st.warning(f"‚ö†Ô∏è ¬øEliminar '{doc.get('filename', '')}'?")
                            
                            col_confirm1, col_confirm2 = st.columns(2)
                            
                            with col_confirm1:
                                if st.button("‚úÖ Confirmar", key=f"confirm_{i}"):
                                    delete_document(doc.get('filename', ''), i)
                            
                            with col_confirm2:
                                if st.button("‚ùå Cancelar", key=f"cancel_{i}"):
                                    st.session_state[f'delete_doc_{i}'] = False
                                    st.rerun()
                        
                        st.markdown("---")
                    
                    # Bot√≥n de limpieza general
                    st.markdown("### üõ†Ô∏è Administraci√≥n")
                    
                    col_admin1, col_admin2 = st.columns(2)
                    
                    with col_admin1:
                        if st.button("üóëÔ∏è Limpiar Todo", type="secondary", use_container_width=True):
                            st.session_state['confirm_clear_all'] = True
                    
                    with col_admin2:
                        if st.button("üîÑ Actualizar", use_container_width=True):
                            st.rerun()
                    
                    # Confirmaci√≥n de limpieza total
                    if st.session_state.get('confirm_clear_all', False):
                        st.error("‚ö†Ô∏è **ATENCI√ìN**: Esta acci√≥n eliminar√° TODOS los documentos")
                        
                        col_final1, col_final2 = st.columns(2)
                        
                        with col_final1:
                            if st.button("üíÄ S√ç, ELIMINAR TODO"):
                                clear_all_documents()
                        
                        with col_final2:
                            if st.button("‚ùå Cancelar operaci√≥n"):
                                st.session_state['confirm_clear_all'] = False
                                st.rerun()
                
                else:
                    st.markdown("""
                    <div class="upload-area">
                        <h3 style="color: #667eea;">üì≠ No hay documentos</h3>
                        <p>Ve a la pesta√±a "üí¨ Chat Inteligente" para subir tu primer documento</p>
                    </div>
                    """, unsafe_allow_html=True)
            else:
                st.error("‚ùå Error obteniendo documentos")
        else:
            st.error("‚ùå Error de conexi√≥n")
    except Exception as e:
        st.error(f"‚ùå Error: {str(e)}")
    
    st.markdown('</div>', unsafe_allow_html=True)

def delete_document(filename, index):
    """Elimina un documento espec√≠fico"""
    try:
        with st.spinner(f"üóëÔ∏è Eliminando '{filename}'..."):
            response = requests.delete(f"{API_BASE_URL}/api/chat/documents/{filename}", timeout=30)
            
            if response.status_code == 200:
                result = response.json()
                if result.get('success', False):
                    st.success(f"‚úÖ Documento '{filename}' eliminado")
                    st.session_state[f'delete_doc_{index}'] = False
                    st.rerun()
                else:
                    st.error(f"‚ùå Error: {result.get('error')}")
            else:
                st.error(f"‚ùå Error del servidor: {response.status_code}")
    except Exception as e:
        st.error(f"‚ùå Error: {str(e)}")

def clear_all_documents():
    """Elimina todos los documentos"""
    try:
        with st.spinner("üóëÔ∏è Eliminando todos los documentos..."):
            response = requests.delete(f"{API_BASE_URL}/api/chat/documents", timeout=30)
            
            if response.status_code == 200:
                result = response.json()
                if result.get('success', False):
                    st.success("‚úÖ Todos los documentos eliminados")
                    st.session_state['confirm_clear_all'] = False
                    st.rerun()
                else:
                    st.error(f"‚ùå Error: {result.get('error')}")
            else:
                st.error(f"‚ùå Error del servidor: {response.status_code}")
    except Exception as e:
        st.error(f"‚ùå Error: {str(e)}")

def modern_analysis_page():
    """P√°gina moderna de an√°lisis avanzado"""
    st.markdown("### üî¨ An√°lisis Avanzado")
    
    # Tabs para diferentes tipos de an√°lisis
    tab1, tab2, tab3 = st.tabs(["üìù Res√∫menes", "üè∑Ô∏è Clasificaci√≥n", "‚öñÔ∏è Comparaciones"])
    
    with tab1:
        st.markdown("#### üìù Generaci√≥n de Res√∫menes")
        
        col1, col2 = st.columns(2)
        
        with col1:
            summary_type = st.selectbox(
                "Tipo de resumen:",
                ["comprehensive", "executive", "technical", "bullet_points"],
                format_func=lambda x: {
                    "comprehensive": "üìä Completo",
                    "executive": "üíº Ejecutivo",
                    "technical": "üîß T√©cnico", 
                    "bullet_points": "üìã Puntos Clave"
                }.get(x, x)
            )
        
        with col2:
            max_tokens = st.slider("Longitud:", 200, 1500, 800, 100)
        
        if st.button("üìù Generar Resumen", type="primary", use_container_width=True):
            st.info("üöß Funci√≥n en desarrollo - Pr√≥ximamente disponible")
    
    with tab2:
        st.markdown("#### üè∑Ô∏è Clasificaci√≥n de Temas")
        
        st.info("üöß Clasificaci√≥n autom√°tica de documentos - En desarrollo")
    
    with tab3:
        st.markdown("#### ‚öñÔ∏è An√°lisis Comparativo")
        
        st.info("üöß Comparaci√≥n de documentos - En desarrollo")

def main_page():
    """P√°gina principal: Upload + Chat integrado"""
    
    # Layout en dos columnas
    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.subheader("üì§ Subir Documentos")
        
        # Upload simplificado
        uploaded_file = st.file_uploader(
            "Arrastra tu PDF aqu√≠",
            type=['pdf'],
            help="M√°ximo 50MB por archivo"
        )
        
        if uploaded_file is not None:
            st.success(f"üìÑ {uploaded_file.name}")
            st.caption(f"üìä {uploaded_file.size / 1024:.1f} KB")
            
            # Procesar autom√°ticamente cuando se sube un archivo
            if f"processed_{uploaded_file.name}" not in st.session_state:
                with st.spinner("üöÄ Procesando autom√°ticamente..."):
                    result = send_document_to_api(uploaded_file)
                    
                    if result:
                        st.success("‚úÖ Procesado autom√°ticamente!")
                        st.session_state[f"processed_{uploaded_file.name}"] = True
                        
                        # Estad√≠sticas compactas
                        doc_stats = result.get('document_stats', {})
                        col_a, col_b = st.columns(2)
                        with col_a:
                            st.metric("üìÑ", doc_stats.get('total_pages', 0))
                        with col_b:
                            st.metric("üß©", doc_stats.get('fragments_count', 0))
                    else:
                        st.error("‚ùå Error procesando el archivo")
            else:
                st.info("‚úÖ Ya procesado - Listo para chat")
        
        # Estado del sistema compacto
        st.divider()
        try:
            status_response = requests.get(f"{API_BASE_URL}/api/chat/status", timeout=3)
            if status_response.status_code == 200:
                status_data = status_response.json()
                llm_status = status_data.get("llm_service", {})
                vector_status = status_data.get("vector_database", {})
                
                if llm_status.get("ollama_connected", False):
                    st.success("ü§ñ IA Local Activa")
                else:
                    st.warning("ü§ñ IA Local: Desconectada")
                
                if vector_status.get("connected", False):
                    chunks = vector_status.get("total_chunks", 0)
                    st.info(f"üóÑÔ∏è {chunks} fragmentos en BD")
                else:
                    st.error("‚ùå Base de datos desconectada")
            else:
                st.error("‚ùå Backend no disponible")
        except:
            st.error("‚ùå Error de conexi√≥n")
    
    with col2:
        st.subheader("üí¨ Chat Conversacional")
        
        # Configuraci√≥n del chat
        with st.expander("‚öôÔ∏è Configuraci√≥n", expanded=False):
            col_a, col_b = st.columns(2)
            with col_a:
                max_results = st.slider("Documentos relevantes:", 1, 10, 7, key="chat_max_results")
            with col_b:
                similarity_threshold = st.slider("Umbral similaridad:", 0.1, 1.0, 0.3, 0.1, key="chat_similarity")
        
        # √Årea de chat
        if "chat_history" not in st.session_state:
            st.session_state.chat_history = []
        
        # Mostrar historial
        chat_container = st.container()
        with chat_container:
            for i, message in enumerate(st.session_state.chat_history):
                if message["role"] == "user":
                    st.markdown(f"**üôã‚Äç‚ôÇÔ∏è T√∫:** {message['content']}")
                else:
                    st.markdown(f"**ü§ñ IA:** {message['content']}")
                    
                    # Mostrar documentos relevantes de forma compacta
                    if message.get("documents"):
                        with st.expander(f"üìö {len(message['documents'])} documentos consultados", expanded=False):
                            for doc in message["documents"][:3]:  # M√°ximo 3
                                st.caption(f"üìÑ {doc.get('filename', 'Sin nombre')} (similaridad: {doc.get('similarity_score', 0):.2f})")
                st.divider()
        
        # Input de chat
        user_question = st.text_input(
            "Escribe tu pregunta:",
            placeholder="¬øQu√© quieres saber sobre tus documentos?",
            key="chat_input"
        )
        
        col_send, col_clear = st.columns([3, 1])
        
        with col_send:
            if st.button("üì§ Enviar", type="primary", use_container_width=True, key="main_send_chat") and user_question:
                process_chat_message(user_question, max_results, similarity_threshold)
        
        with col_clear:
            if st.button("üóëÔ∏è Limpiar", use_container_width=True, key="main_clear_chat"):
                st.session_state.chat_history = []
                st.rerun()

def process_chat_message(question: str, max_results: int, similarity_threshold: float):
    """Procesa un mensaje de chat"""
    try:
        # Agregar pregunta del usuario al historial
        st.session_state.chat_history.append({
            "role": "user",
            "content": question
        })
        
        # Hacer request al backend
        with st.spinner("ü§î Pensando..."):
            response = requests.post(
                f"{API_BASE_URL}/api/chat/chat",
                json={
                    "question": question,
                    "max_results": max_results,
                    "similarity_threshold": similarity_threshold
                },
                timeout=30
            )
        
        if response.status_code == 200:
            result = response.json()
            
            # Agregar respuesta de la IA al historial
            st.session_state.chat_history.append({
                "role": "assistant",
                "content": result.get("answer", "No pude generar una respuesta."),
                "documents": result.get("relevant_documents", []),
                "confidence": result.get("confidence_score", 0),
                "llm_used": result.get("llm_used", "unknown")
            })
        else:
            st.error(f"Error del servidor: {response.status_code}")
            
    except requests.exceptions.Timeout:
        st.error("‚è∞ La consulta est√° tomando m√°s tiempo del esperado")
    except requests.exceptions.ConnectionError:
        st.error("üîå Error de conexi√≥n con el backend")
    except Exception as e:
        st.error(f"‚ùå Error: {str(e)}")
    
    # Refrescar la p√°gina para mostrar la nueva conversaci√≥n
    st.rerun()

def documents_page():
    """P√°gina para visualizar documentos procesados"""
    st.subheader("üìÑ Documentos Procesados")
    
    # Bot√≥n para refrescar
    col1, col2 = st.columns([3, 1])
    with col1:
        st.markdown("**Visualiza todos los documentos que est√°n en el sistema**")
    with col2:
        refresh_button = st.button("üîÑ Refrescar", key="refresh_docs")
    
    if refresh_button:
        # Limpiar cach√© si existe
        if 'documents_data' in st.session_state:
            del st.session_state['documents_data']
    
    # Obtener lista de documentos
    if 'documents_data' not in st.session_state or refresh_button:
        with st.spinner("üìö Cargando documentos..."):
            try:
                response = requests.get(f"{API_BASE_URL}/api/chat/documents", timeout=10)
                
                if response.status_code == 200:
                    st.session_state['documents_data'] = response.json()
                else:
                    st.error(f"‚ùå Error del servidor: {response.status_code}")
                    return
                    
            except requests.exceptions.ConnectionError:
                st.error("üîå Error de conexi√≥n con el backend")
                return
            except Exception as e:
                st.error(f"‚ùå Error: {str(e)}")
                return
    
    # Mostrar informaci√≥n general
    docs_data = st.session_state.get('documents_data', {})
    
    if docs_data.get('success', False):
        documents = docs_data.get('documents', [])
        total_docs = docs_data.get('total_documents', 0)
        total_fragments = docs_data.get('total_fragments', 0)
        
        # Estad√≠sticas generales
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("üìÑ Total Documentos", total_docs)
        with col2:
            st.metric("üß© Total Fragmentos", total_fragments)
        with col3:
            avg_fragments = round(total_fragments / total_docs, 1) if total_docs > 0 else 0
            st.metric("üìä Promedio Fragmentos", avg_fragments)
        
        if documents:
            st.divider()
            
            # Ordenar documentos por fecha de subida (m√°s recientes primero)
            try:
                documents_sorted = sorted(documents, 
                                        key=lambda x: x.get('upload_date', ''), 
                                        reverse=True)
            except:
                documents_sorted = documents
            
            # Mostrar cada documento
            for i, doc in enumerate(documents_sorted):
                with st.expander(f"üìÑ {doc.get('filename', 'Sin nombre')}", expanded=False):
                    
                    # Informaci√≥n b√°sica del documento
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        st.write(f"**üìÖ Fecha de subida:** {doc.get('upload_date', 'No disponible')}")
                        st.write(f"**üìè Tama√±o:** {doc.get('file_size', 0):,} bytes")
                        st.write(f"**üìë P√°ginas:** {doc.get('total_pages', 0)}")
                    
                    with col2:
                        st.write(f"**üß© Fragmentos:** {doc.get('fragment_count', 0)}")
                        
                        # Calcular densidad de fragmentos
                        pages = doc.get('total_pages', 1)
                        fragments = doc.get('fragment_count', 0)
                        density = round(fragments / pages, 1) if pages > 0 else 0
                        st.write(f"**üìä Fragmentos/p√°gina:** {density}")
                    
                    # Vista previa del contenido
                    content_preview = doc.get('content_preview', '')
                    if content_preview:
                        st.markdown("**üëÄ Vista previa del contenido:**")
                        st.text_area(
                            "",
                            content_preview,
                            height=120,
                            disabled=True,
                            key=f"preview_{i}"
                        )
                    
                    # Acciones del documento
                    col_actions = st.columns(3)
                    
                    with col_actions[0]:
                        if st.button(f"üîç Buscar en documento", key=f"search_{i}"):
                            st.session_state[f'search_doc_{i}'] = True
                    
                    with col_actions[1]:
                        if st.button(f"üìù Resumir documento", key=f"summarize_{i}"):
                            st.session_state[f'summarize_doc_{i}'] = True
                    
                    with col_actions[2]:
                        if st.button(f"‚ùå Eliminar", key=f"delete_{i}"):
                            st.session_state[f'delete_doc_{i}'] = True
                    
                    # Manejo de acciones
                    if st.session_state.get(f'search_doc_{i}', False):
                        st.info("üöß Funci√≥n de b√∫squeda en documento espec√≠fico en desarrollo")
                        st.session_state[f'search_doc_{i}'] = False
                    
                    if st.session_state.get(f'summarize_doc_{i}', False):
                        st.info("üöß Funci√≥n de resumen de documento espec√≠fico en desarrollo")
                        st.session_state[f'summarize_doc_{i}'] = False
                    
                    if st.session_state.get(f'delete_doc_{i}', False):
                        # Implementar eliminaci√≥n real
                        filename = doc.get('filename', '')
                        
                        # Confirmaci√≥n de eliminaci√≥n
                        st.warning(f"‚ö†Ô∏è ¬øEst√°s seguro de que quieres eliminar '{filename}'?")
                        
                        col_confirm = st.columns(2)
                        with col_confirm[0]:
                            if st.button(f"‚úÖ S√≠, eliminar", key=f"confirm_delete_{i}"):
                                # Ejecutar eliminaci√≥n
                                with st.spinner(f"üóëÔ∏è Eliminando '{filename}'..."):
                                    try:
                                        response = requests.delete(
                                            f"{API_BASE_URL}/api/chat/documents/{filename}",
                                            timeout=30
                                        )
                                        
                                        if response.status_code == 200:
                                            result = response.json()
                                            if result.get('success', False):
                                                st.success(f"‚úÖ Documento '{filename}' eliminado exitosamente")
                                                # Limpiar cach√© para refrescar
                                                if 'documents_data' in st.session_state:
                                                    del st.session_state['documents_data']
                                                st.rerun()
                                            else:
                                                st.error(f"‚ùå Error: {result.get('error', 'Error desconocido')}")
                                        else:
                                            st.error(f"‚ùå Error del servidor: {response.status_code}")
                                            
                                    except requests.exceptions.ConnectionError:
                                        st.error("üîå Error de conexi√≥n con el backend")
                                    except Exception as e:
                                        st.error(f"‚ùå Error: {str(e)}")
                                
                                st.session_state[f'delete_doc_{i}'] = False
                        
                        with col_confirm[1]:
                            if st.button(f"‚ùå Cancelar", key=f"cancel_delete_{i}"):
                                st.session_state[f'delete_doc_{i}'] = False
                                st.rerun()
            
            # Informaci√≥n adicional
            st.divider()
            
            # Acciones de administraci√≥n
            st.subheader("üõ†Ô∏è Administraci√≥n de Base de Datos")
            
            col_admin = st.columns(3)
            
            with col_admin[0]:
                if st.button("üóëÔ∏è Limpiar todo", type="secondary", help="Elimina TODOS los documentos"):
                    st.session_state['show_clear_all_confirm'] = True
            
            with col_admin[1]:
                if st.button("üìä Ver fragmentos", help="Ver fragmentos detallados"):
                    st.session_state['show_fragments_view'] = True
            
            with col_admin[2]:
                if st.button("üîÑ Reconstruir √≠ndice", help="Reconstruir √≠ndice de b√∫squeda"):
                    st.info("üöß Funci√≥n en desarrollo")
            
            # Confirmaci√≥n para limpiar todo
            if st.session_state.get('show_clear_all_confirm', False):
                st.warning("‚ö†Ô∏è **ATENCI√ìN**: Esta acci√≥n eliminar√° TODOS los documentos y fragmentos.")
                st.markdown("**Esta acci√≥n NO se puede deshacer.**")
                
                col_clear_confirm = st.columns(2)
                with col_clear_confirm[0]:
                    if st.button("üíÄ S√ç, ELIMINAR TODO", type="primary"):
                        with st.spinner("üóëÔ∏è Eliminando todos los documentos..."):
                            try:
                                response = requests.delete(
                                    f"{API_BASE_URL}/api/chat/documents",
                                    timeout=30
                                )
                                
                                if response.status_code == 200:
                                    result = response.json()
                                    if result.get('success', False):
                                        st.success(f"‚úÖ {result.get('message', 'Todos los documentos eliminados')}")
                                        st.info(f"üóëÔ∏è Fragmentos eliminados: {result.get('fragments_deleted', 0)}")
                                        # Limpiar cach√©
                                        if 'documents_data' in st.session_state:
                                            del st.session_state['documents_data']
                                        st.session_state['show_clear_all_confirm'] = False
                                        st.rerun()
                                    else:
                                        st.error(f"‚ùå Error: {result.get('error', 'Error desconocido')}")
                                else:
                                    st.error(f"‚ùå Error del servidor: {response.status_code}")
                                    
                            except requests.exceptions.ConnectionError:
                                st.error("üîå Error de conexi√≥n con el backend")
                            except Exception as e:
                                st.error(f"‚ùå Error: {str(e)}")
                
                with col_clear_confirm[1]:
                    if st.button("‚ùå Cancelar"):
                        st.session_state['show_clear_all_confirm'] = False
                        st.rerun()
            
            # Vista de fragmentos detallada
            if st.session_state.get('show_fragments_view', False):
                st.markdown("### üß© Vista detallada de fragmentos")
                
                # Selector de documento para ver fragmentos
                document_names = [doc.get('filename', '') for doc in documents if doc.get('filename')]
                if document_names:
                    selected_doc = st.selectbox(
                        "Selecciona un documento para ver sus fragmentos:",
                        document_names,
                        key="fragment_view_selector"
                    )
                    
                    if st.button("üîç Ver fragmentos"):
                        with st.spinner(f"üìö Cargando fragmentos de '{selected_doc}'..."):
                            try:
                                response = requests.get(
                                    f"{API_BASE_URL}/api/chat/documents/{selected_doc}/fragments",
                                    timeout=30
                                )
                                
                                if response.status_code == 200:
                                    result = response.json()
                                    if result.get('success', False):
                                        fragments = result.get('fragments', [])
                                        total_fragments = result.get('total_fragments', 0)
                                        
                                        st.success(f"üìä {total_fragments} fragmentos encontrados en '{selected_doc}'")
                                        
                                        for j, fragment in enumerate(fragments):
                                            with st.expander(f"Fragmento {j+1} (ID: {fragment.get('id', 'N/A')[:8]}...)", expanded=False):
                                                st.write(f"**Longitud:** {fragment.get('content_length', 0)} caracteres")
                                                st.text_area(
                                                    "Contenido:",
                                                    fragment.get('content_preview', ''),
                                                    height=100,
                                                    disabled=True,
                                                    key=f"fragment_content_{j}"
                                                )
                                                
                                                # Metadatos del fragmento
                                                metadata = fragment.get('metadata', {})
                                                if metadata:
                                                    st.json(metadata)
                                                
                                                # Bot√≥n para eliminar fragmento individual
                                                if st.button(f"üóëÔ∏è Eliminar fragmento", key=f"delete_fragment_{j}"):
                                                    fragment_id = fragment.get('id')
                                                    if fragment_id:
                                                        with st.spinner("Eliminando fragmento..."):
                                                            try:
                                                                del_response = requests.delete(
                                                                    f"{API_BASE_URL}/api/chat/fragments",
                                                                    json=[fragment_id],
                                                                    timeout=30
                                                                )
                                                                
                                                                if del_response.status_code == 200:
                                                                    del_result = del_response.json()
                                                                    if del_result.get('success', False):
                                                                        st.success("‚úÖ Fragmento eliminado")
                                                                        st.rerun()
                                                                    else:
                                                                        st.error(f"‚ùå Error: {del_result.get('error')}")
                                                                else:
                                                                    st.error(f"‚ùå Error del servidor: {del_response.status_code}")
                                                            except Exception as e:
                                                                st.error(f"‚ùå Error: {str(e)}")
                                    else:
                                        st.error(f"‚ùå Error: {result.get('error', 'Error desconocido')}")
                                else:
                                    st.error(f"‚ùå Error del servidor: {response.status_code}")
                                    
                            except Exception as e:
                                st.error(f"‚ùå Error: {str(e)}")
                
                if st.button("‚ùå Cerrar vista de fragmentos"):
                    st.session_state['show_fragments_view'] = False
                    st.rerun()
            
            with st.expander("‚ÑπÔ∏è Informaci√≥n del Sistema"):
                db_status = docs_data.get('database_status', {})
                st.json(db_status)
                
        else:
            st.info("üì≠ No hay documentos procesados en el sistema.")
            st.markdown("**Para agregar documentos:**")
            st.markdown("1. Ve a la p√°gina 'üí¨ Chat & Upload'")
            st.markdown("2. Sube un archivo PDF")
            st.markdown("3. El documento se procesar√° autom√°ticamente")
            
    else:
        st.error(f"‚ùå Error obteniendo documentos: {docs_data.get('error', 'Error desconocido')}")

def advanced_analysis_page():
    """P√°gina de an√°lisis avanzado"""
    st.subheader("üî¨ An√°lisis Avanzado de Documentos")
    
    # Tabs para diferentes an√°lisis
    tab1, tab2, tab3 = st.tabs(["üìù Resumen", "üè∑Ô∏è Clasificaci√≥n", "‚öñÔ∏è Comparaci√≥n"])
    
    with tab1:
        st.markdown("**Genera res√∫menes especializados**")
        
        col1, col2 = st.columns(2)
        
        with col1:
            summary_type = st.selectbox(
                "Tipo de resumen:",
                ["comprehensive", "executive", "technical", "bullet_points"],
                format_func=lambda x: {
                    "comprehensive": "üìä Completo",
                    "executive": "üíº Ejecutivo", 
                    "technical": "üîß T√©cnico",
                    "bullet_points": "üìã Puntos Clave"
                }.get(x, x),
                key="advanced_summary_type"
            )
        
        with col2:
            max_tokens = st.slider("Longitud:", 200, 1500, 800, 100, key="advanced_max_tokens")
        
        if st.button("üìù Generar Resumen", type="primary", key="advanced_generate_summary"):
            with st.spinner("Generando resumen..."):
                try:
                    response = requests.post(
                        f"{API_BASE_URL}/api/chat/summarize/advanced",
                        json={
                            "summary_type": summary_type,
                            "max_tokens": max_tokens
                        },
                        timeout=30
                    )
                    
                    if response.status_code == 200:
                        result = response.json()
                        if result.get("success"):
                            st.success("‚úÖ Resumen generado!")
                            
                            # M√©tricas
                            col_a, col_b, col_c = st.columns(3)
                            with col_a:
                                st.metric("üìÑ Docs", result.get("documents_processed", 0))
                            with col_b:
                                st.metric("üî§ Tokens", result.get("tokens_used", 0))
                            with col_c:
                                st.metric("ü§ñ", result.get("method", "").replace("_", " ").title())
                            
                            # Resumen
                            st.markdown("**Resumen:**")
                            st.text_area("", result.get("summary", ""), height=300, disabled=True, key="advanced_summary_text")
                            
                            # Descarga
                            st.download_button(
                                "üíæ Descargar",
                                result.get("summary", ""),
                                f"resumen_{summary_type}.txt",
                                "text/plain"
                            )
                        else:
                            st.error(f"‚ùå {result.get('error', 'Error desconocido')}")
                    else:
                        st.error(f"‚ùå Error del servidor: {response.status_code}")
                        
                except Exception as e:
                    st.error(f"‚ùå Error: {str(e)}")
    
    with tab2:
        st.markdown("**Clasifica documentos por temas**")
        
        # Configuraci√≥n
        col1, col2 = st.columns(2)
        
        with col1:
            use_custom = st.checkbox("Etiquetas personalizadas", key="advanced_custom_labels")
            if use_custom:
                custom_labels = st.text_input(
                    "Etiquetas (separadas por comas):",
                    "tecnolog√≠a, ciencia, negocios, salud, educaci√≥n"
                )
                labels = [l.strip() for l in custom_labels.split(",") if l.strip()]
            else:
                labels = None
        
        with col2:
            confidence_threshold = st.slider("Confianza m√≠nima:", 0.1, 0.9, 0.3, 0.1, key="classification_confidence")
        
        if st.button("üè∑Ô∏è Clasificar", type="primary", key="advanced_classify_docs"):
            with st.spinner("Clasificando documentos..."):
                try:
                    response = requests.post(
                        f"{API_BASE_URL}/api/chat/classify/topics",
                        json={
                            "custom_labels": labels,
                            "confidence_threshold": confidence_threshold
                        },
                        timeout=30
                    )
                    
                    if response.status_code == 200:
                        result = response.json()
                        if result.get("success"):
                            st.success("‚úÖ Clasificaci√≥n completada!")
                            
                            # Estad√≠sticas
                            col_a, col_b = st.columns(2)
                            with col_a:
                                st.metric("üìÑ Documentos", result.get("total_documents", 0))
                            with col_b:
                                st.metric("üè∑Ô∏è Temas", len([t for t in result.get("topic_statistics", {}).values() if t > 0]))
                            
                            # Distribuci√≥n
                            topic_stats = result.get("topic_statistics", {})
                            if topic_stats:
                                st.markdown("**Distribuci√≥n de temas:**")
                                for topic, count in sorted(topic_stats.items(), key=lambda x: x[1], reverse=True):
                                    if count > 0:
                                        percentage = (count / result.get("total_documents", 1)) * 100
                                        st.write(f"**{topic.title()}**: {count} docs ({percentage:.1f}%)")
                        else:
                            st.error(f"‚ùå {result.get('error', 'Error desconocido')}")
                    else:
                        st.error(f"‚ùå Error del servidor: {response.status_code}")
                        
                except Exception as e:
                    st.error(f"‚ùå Error: {str(e)}")
    
    with tab3:
        st.markdown("**Compara conjuntos de documentos**")
        
        col1, col2 = st.columns(2)
        
        with col1:
            query1 = st.text_input("Consulta 1:", placeholder="ej: ventajas del enfoque A", key="advanced_query1")
        
        with col2:
            query2 = st.text_input("Consulta 2:", placeholder="ej: ventajas del enfoque B", key="advanced_query2")
        
        if st.button("‚öñÔ∏è Comparar", type="primary", key="advanced_compare_docs") and query1 and query2:
            with st.spinner("Comparando documentos..."):
                try:
                    response = requests.post(
                        f"{API_BASE_URL}/api/chat/summarize/comparative",
                        json={
                            "doc1_query": query1,
                            "doc2_query": query2,
                            "max_results": 3
                        },
                        timeout=30
                    )
                    
                    if response.status_code == 200:
                        result = response.json()
                        if result.get("success"):
                            st.success("‚úÖ Comparaci√≥n completada!")
                            
                            # Estad√≠sticas
                            col_a, col_b = st.columns(2)
                            with col_a:
                                st.metric("üìÑ Grupo 1", result.get("doc1_fragments", 0))
                            with col_b:
                                st.metric("üìÑ Grupo 2", result.get("doc2_fragments", 0))
                            
                            # Comparaci√≥n
                            st.markdown("**An√°lisis comparativo:**")
                            st.text_area("", result.get("comparative_summary", ""), height=300, disabled=True, key="advanced_comparison_text")
                        else:
                            st.error(f"‚ùå {result.get('error', 'Error desconocido')}")
                    else:
                        st.error(f"‚ùå Error del servidor: {response.status_code}")
                        
                except Exception as e:
                    st.error(f"‚ùå Error: {str(e)}")

def upload_page():
    """P√°gina para subir archivos PDF"""
    st.header("üì§ Subir Documentos PDF")
    
    # Mostrar informaci√≥n sobre el procesamiento
    with st.expander("‚ÑπÔ∏è ¬øC√≥mo funciona el procesamiento?"):
        st.markdown("""
        1. **Extracci√≥n de texto**: Se extrae todo el texto del PDF usando PyMuPDF
        2. **Divisi√≥n en fragmentos**: El texto se divide en chunks de ~1000 caracteres
        3. **Generaci√≥n de embeddings**: Cada chunk se convierte en un vector usando IA
        4. **Almacenamiento**: Los vectores se guardan en ChromaDB para b√∫squedas r√°pidas
        """)
    
    # Subida de archivo
    uploaded_file = st.file_uploader(
        "Selecciona un archivo PDF",
        type=['pdf'],
        help="Solo se permiten archivos PDF"
    )
    
    if uploaded_file is not None:
        # Mostrar informaci√≥n del archivo
        st.success(f"üìÑ Archivo seleccionado: {uploaded_file.name}")
        st.info(f"üìä Tama√±o: {uploaded_file.size / 1024:.2f} KB")
        
        # Bot√≥n para procesar
        if st.button("üöÄ Procesar Documento", type="primary"):
            with st.spinner("Procesando documento... Esto puede tomar unos momentos."):
                processing_result = send_document_to_api(uploaded_file)
                
                if processing_result:
                    st.success("‚úÖ ¬°Documento procesado exitosamente!")
                    
                    # Mostrar estad√≠sticas del procesamiento en columnas
                    col1, col2, col3 = st.columns(3)
                    
                    doc_stats = processing_result.get('document_stats', {})
                    with col1:
                        st.metric("üìÑ P√°ginas", doc_stats.get('total_pages', 0))
                        st.metric("üìù Caracteres", doc_stats.get('text_length', 0))
                    
                    with col2:
                        st.metric("üß© Fragmentos", doc_stats.get('fragments_count', 0))
                        st.metric("üî¢ Embeddings", doc_stats.get('embeddings_count', 0))
                    
                    with col3:
                        transformer_info = processing_result.get('model_info', {})
                        st.metric("üìê Dimensi√≥n", doc_stats.get('vector_dimension', 0))
                        st.metric("ü§ñ Modelo", transformer_info.get('model_name', 'N/A').split('/')[-1])
                    
                    # Mostrar metadatos del documento
                    with st.expander("üìã Metadatos del Documento"):
                        doc_metadata = processing_result.get('document_metadata', {})
                        if doc_metadata.get('title'):
                            st.write(f"**T√≠tulo:** {doc_metadata.get('title')}")
                        if doc_metadata.get('author'):
                            st.write(f"**Autor:** {doc_metadata.get('author')}")
                        if doc_metadata.get('subject'):
                            st.write(f"**Tema:** {doc_metadata.get('subject')}")
                        if doc_metadata.get('creator'):
                            st.write(f"**Creador:** {doc_metadata.get('creator')}")
                    
                    # Mostrar vista previa de fragmentos
                    with st.expander("üëÄ Vista Previa de Fragmentos"):
                        sample_fragments = processing_result.get('sample_fragments', [])
                        for index, fragment in enumerate(sample_fragments[:3]):
                            st.write(f"**Fragmento {index+1}:**")
                            st.text_area(f"fragment_{index}", fragment, height=100, disabled=True, key=f"fragment_text_{index}")
                    
                    # Informaci√≥n de la base de datos vectorial
                    with st.expander("üóÑÔ∏è Estado de la Base de Datos"):
                        db_status = processing_result.get('database_status', {})
                        st.json(db_status)

def chat_page():
    """P√°gina para chat con documentos"""
    st.header("üí¨ Chat con Documentos")
    
    # Verificar estado del sistema
    try:
        status_response = requests.get(f"{API_BASE_URL}/api/chat/status", timeout=5)
        if status_response.status_code == 200:
            status_data = status_response.json()
            llm_status = status_data.get("llm_service", {})
            
            # Mostrar estado del sistema
            col1, col2, col3 = st.columns(3)
            with col1:
                if llm_status.get("ollama_connected", False):
                    st.success("ü§ñ Ollama Conectado")
                else:
                    st.error("‚ùå Ollama Desconectado")
            
            with col2:
                if llm_status.get("langchain_available", False):
                    st.success("üîó LangChain Activo")
                else:
                    st.warning("‚ö†Ô∏è LangChain No Disponible")
            
            with col3:
                vector_db = status_data.get("vector_database", {})
                total_chunks = vector_db.get("total_chunks", 0)
                st.info(f"üìö {total_chunks} fragmentos disponibles")
        else:
            st.error("‚ùå No se puede conectar al sistema de chat")
            return
    except Exception as e:
        st.error(f"‚ùå Error verificando estado: {str(e)}")
        return
    
    # Inicializar historial de chat en session state
    if "chat_history" not in st.session_state:
        st.session_state.chat_history = []
    
    if "chat_input_key" not in st.session_state:
        st.session_state.chat_input_key = 0
    
    # Configuraci√≥n del chat
    st.subheader("‚öôÔ∏è Configuraci√≥n")
    col1, col2 = st.columns(2)
    
    with col1:
        max_results = st.slider(
            "ÔøΩ M√°ximo de fragmentos relevantes:", 
            min_value=1, max_value=10, value=5,
            help="N√∫mero m√°ximo de fragmentos de documentos a considerar"
        )
    
    with col2:
        similarity_threshold = st.slider(
            "üéØ Umbral de similitud:", 
            min_value=0.0, max_value=1.0, value=0.5, step=0.1,
            help="Umbral m√≠nimo de similitud para considerar un fragmento relevante"
        )
    
    # √Årea de chat
    st.subheader("üí¨ Conversaci√≥n")
    
    # Mostrar historial de chat
    chat_container = st.container()
    with chat_container:
        for i, message in enumerate(st.session_state.chat_history):
            if message["role"] == "user":
                st.chat_message("user").write(message["content"])
            else:
                with st.chat_message("assistant"):
                    st.write(message["content"])
                    
                    # Mostrar metadatos si est√°n disponibles
                    if "metadata" in message:
                        metadata = message["metadata"]
                        with st.expander("üìä Detalles de la respuesta"):
                            col1, col2 = st.columns(2)
                            with col1:
                                st.write(f"**M√©todo:** {metadata.get('method', 'N/A')}")
                                st.write(f"**Fragmentos usados:** {metadata.get('relevant_documents', 0)}")
                            with col2:
                                if metadata.get('langchain_used'):
                                    st.success("üîó LangChain utilizado")
                                else:
                                    st.info("ü§ñ Ollama directo")
    
    # Campo de entrada para nueva pregunta
    st.subheader("‚úçÔ∏è Haz tu pregunta")
    
    # Usar form para mejor UX
    with st.form(key=f"chat_form_{st.session_state.chat_input_key}", clear_on_submit=True):
        user_question = st.text_area(
            "Pregunta:",
            placeholder="Ej: ¬øCu√°les son los puntos principales del documento?",
            height=100,
            help="Escribe tu pregunta sobre los documentos subidos"
        )
        
        col1, col2, col3 = st.columns([1, 1, 2])
        with col1:
            submit_button = st.form_submit_button("üöÄ Enviar", type="primary")
        with col2:
            clear_button = st.form_submit_button("üóëÔ∏è Limpiar Chat")
    
    # Procesar env√≠o de pregunta
    if submit_button and user_question.strip():
        # Agregar pregunta del usuario al historial
        st.session_state.chat_history.append({
            "role": "user", 
            "content": user_question
        })
        
        # Mostrar la pregunta inmediatamente
        with chat_container:
            st.chat_message("user").write(user_question)
        
        # Enviar pregunta al backend
        with st.spinner("ü§î Generando respuesta..."):
            try:
                chat_request = {
                    "question": user_question,
                    "max_results": max_results,
                    "similarity_threshold": similarity_threshold
                }
                
                response = requests.post(
                    f"{API_BASE_URL}/api/chat/simple",
                    json=chat_request,
                    timeout=30
                )
                
                if response.status_code == 200:
                    chat_response = response.json()
                    
                    if "error" in chat_response:
                        answer = f"‚ùå Error: {chat_response['error']}"
                        metadata = {"method": "error", "relevant_documents": 0}
                    else:
                        answer = chat_response.get("response", "No se recibi√≥ respuesta")
                        metadata = {
                            "method": chat_response.get("method", "unknown"),
                            "relevant_documents": chat_response.get("relevant_documents", 0),
                            "langchain_used": chat_response.get("langchain_used", False)
                        }
                    
                    # Agregar respuesta al historial
                    st.session_state.chat_history.append({
                        "role": "assistant",
                        "content": answer,
                        "metadata": metadata
                    })
                    
                    # Mostrar respuesta inmediatamente
                    with chat_container:
                        with st.chat_message("assistant"):
                            st.write(answer)
                            
                            with st.expander("üìä Detalles de la respuesta"):
                                col1, col2 = st.columns(2)
                                with col1:
                                    st.write(f"**M√©todo:** {metadata.get('method', 'N/A')}")
                                    st.write(f"**Fragmentos usados:** {metadata.get('relevant_documents', 0)}")
                                with col2:
                                    if metadata.get('langchain_used'):
                                        st.success("üîó LangChain utilizado")
                                    else:
                                        st.info("ü§ñ Ollama directo")
                else:
                    error_msg = f"‚ùå Error del servidor: {response.status_code}"
                    st.session_state.chat_history.append({
                        "role": "assistant",
                        "content": error_msg,
                        "metadata": {"method": "error", "relevant_documents": 0}
                    })
                    
                    with chat_container:
                        st.chat_message("assistant").write(error_msg)
                        
            except requests.exceptions.Timeout:
                timeout_msg = "‚è±Ô∏è Tiempo de espera agotado. El modelo puede estar procesando una consulta compleja."
                st.session_state.chat_history.append({
                    "role": "assistant",
                    "content": timeout_msg,
                    "metadata": {"method": "timeout", "relevant_documents": 0}
                })
                
                with chat_container:
                    st.chat_message("assistant").write(timeout_msg)
                    
            except Exception as e:
                error_msg = f"‚ùå Error inesperado: {str(e)}"
                st.session_state.chat_history.append({
                    "role": "assistant",
                    "content": error_msg,
                    "metadata": {"method": "error", "relevant_documents": 0}
                })
                
                with chat_container:
                    st.chat_message("assistant").write(error_msg)
        
        # Incrementar key para limpiar el form
        st.session_state.chat_input_key += 1
        st.rerun()
    
    # Procesar limpieza de chat
    if clear_button:
        st.session_state.chat_history = []
        st.session_state.chat_input_key += 1
        st.success("üóëÔ∏è Chat limpiado exitosamente")
        st.rerun()
    
    # Botones adicionales
    st.subheader("üõ†Ô∏è Acciones Adicionales")
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("üìÑ Generar Resumen de Chat"):
            if st.session_state.chat_history:
                # Combinar todas las preguntas y respuestas
                chat_text = "\n\n".join([
                    f"{'Usuario' if msg['role'] == 'user' else 'Asistente'}: {msg['content']}"
                    for msg in st.session_state.chat_history
                ])
                
                st.text_area("üìÑ Resumen de la conversaci√≥n:", chat_text, height=200, key="chat_summary_text")
            else:
                st.info("No hay conversaci√≥n para resumir")
    
    with col2:
        if st.button("üíæ Descargar Chat"):
            if st.session_state.chat_history:
                # Crear archivo de descarga
                chat_export = {
                    "timestamp": str(st.timestamp if hasattr(st, 'timestamp') else ""),
                    "messages": st.session_state.chat_history
                }
                
                st.download_button(
                    label="‚¨áÔ∏è Descargar JSON",
                    data=json.dumps(chat_export, indent=2, ensure_ascii=False),
                    file_name="chat_conversation.json",
                    mime="application/json"
                )
            else:
                st.info("No hay conversaci√≥n para descargar")
    
    # Ayuda y ejemplos
    with st.expander("üí° Ejemplos de preguntas"):
        st.markdown("""
        **Preguntas de an√°lisis:**
        - ¬øCu√°les son los puntos principales del documento?
        - ¬øQu√© conclusiones presenta el autor?
        - ¬øHay datos estad√≠sticos relevantes?
        
        **Preguntas espec√≠ficas:**
        - ¬øQu√© dice sobre [tema espec√≠fico]?
        - ¬øCu√°les son las recomendaciones mencionadas?
        - ¬øHay fechas o n√∫meros importantes?
        
        **Preguntas comparativas:**
        - ¬øC√≥mo se relaciona esto con [concepto]?
        - ¬øCu√°les son las ventajas y desventajas mencionadas?
        """)
    
    # Informaci√≥n t√©cnica
    with st.expander("üîß Informaci√≥n T√©cnica"):
        st.markdown(f"""
        **Configuraci√≥n actual:**
        - Fragmentos m√°ximos: {max_results}
        - Umbral de similitud: {similarity_threshold}
        - Mensajes en historial: {len(st.session_state.chat_history)}
        
        **Estado del sistema:**
        - Backend: {API_BASE_URL}
        - LLM: {"Ollama + LangChain" if llm_status.get("langchain_available") else "Ollama directo"}
        - Base vectorial: ChromaDB
        """)

def summary_page():
    """P√°gina para generar res√∫menes"""
    st.header("üìÑ Generar Res√∫menes")
    
    # Verificar estado del sistema
    try:
        status_response = requests.get(f"{API_BASE_URL}/api/chat/status", timeout=5)
        if status_response.status_code == 200:
            status_data = status_response.json()
            vector_db = status_data.get("vector_database", {})
            total_chunks = vector_db.get("total_chunks", 0)
            
            if total_chunks == 0:
                st.warning("‚ö†Ô∏è No hay documentos cargados. Ve a 'Subir Documentos' primero.")
                return
            else:
                st.success(f"üìö {total_chunks} fragmentos de documentos disponibles")
        else:
            st.error("‚ùå No se puede conectar al sistema")
            return
    except Exception as e:
        st.error(f"‚ùå Error verificando estado: {str(e)}")
        return
    
    st.markdown("Genera res√∫menes autom√°ticos de tus documentos usando IA.")
    
    # Opciones de resumen
    st.subheader("‚öôÔ∏è Configuraci√≥n del Resumen")
    
    col1, col2 = st.columns(2)
    with col1:
        summary_type = st.selectbox(
            "Tipo de resumen:",
            ["Colecci√≥n completa", "Documento espec√≠fico"],
            help="Elige si quieres resumir todos los documentos o uno espec√≠fico"
        )
    
    with col2:
        max_length = st.slider(
            "Longitud m√°xima:",
            min_value=100, max_value=1000, value=500,
            help="N√∫mero m√°ximo de caracteres en el resumen"
        )
    
    # Generar resumen
    if st.button("üìù Generar Resumen", type="primary"):
        with st.spinner("ü§ñ Generando resumen..."):
            try:
                summary_request = {
                    "max_length": max_length
                }
                
                if summary_type == "Documento espec√≠fico":
                    # TODO: Implementar selecci√≥n de documento espec√≠fico
                    st.info("üöß Selecci√≥n de documento espec√≠fico en desarrollo")
                    return
                
                response = requests.post(
                    f"{API_BASE_URL}/api/summarize",
                    json=summary_request,
                    timeout=60
                )
                
                if response.status_code == 200:
                    summary_response = response.json()
                    
                    if summary_response.get("success", False):
                        st.success("‚úÖ Resumen generado exitosamente")
                        
                        # Mostrar resumen
                        st.subheader("üìã Resumen Generado")
                        summary_text = summary_response.get("summary", "")
                        st.markdown(summary_text)
                        
                        # Mostrar estad√≠sticas
                        col1, col2 = st.columns(2)
                        with col1:
                            st.metric("üìä Documentos analizados", summary_response.get("documents_analyzed", 0))
                        with col2:
                            st.metric("üîß M√©todo usado", summary_response.get("method", "unknown"))
                        
                        # Opci√≥n de descarga
                        st.download_button(
                            label="‚¨áÔ∏è Descargar Resumen",
                            data=summary_text,
                            file_name="resumen_documentos.txt",
                            mime="text/plain"
                        )
                        
                    else:
                        st.error(f"‚ùå Error generando resumen: {summary_response.get('error', 'Error desconocido')}")
                else:
                    st.error(f"‚ùå Error del servidor: {response.status_code}")
                    
            except requests.exceptions.Timeout:
                st.error("‚è±Ô∏è Tiempo de espera agotado. El resumen puede estar tardando m√°s de lo esperado.")
            except Exception as e:
                st.error(f"‚ùå Error inesperado: {str(e)}")
    
    # Informaci√≥n adicional
    with st.expander("üí° Tipos de resumen disponibles"):
        st.markdown("""
        **Resumen de colecci√≥n completa:**
        - Analiza todos los documentos cargados
        - Identifica temas principales y patrones comunes
        - Proporciona una vista general de toda la informaci√≥n
        
        **Resumen de documento espec√≠fico:**
        - Analiza un documento individual
        - Extrae puntos clave espec√≠ficos del documento
        - M√°s detallado y enfocado
        """)
    
    with st.expander("üîß C√≥mo funciona"):
        st.markdown("""
        1. **Selecci√≥n de contenido**: Se seleccionan fragmentos representativos de los documentos
        2. **An√°lisis con IA**: El modelo de lenguaje analiza el contenido
        3. **Estructuraci√≥n**: Se genera un resumen estructurado con:
           - Resumen ejecutivo
           - Puntos clave
           - Temas principales
           - Conclusiones relevantes
        """)

def comparison_page():
    """P√°gina para comparar documentos"""
    st.header("‚öñÔ∏è Comparar Documentos")
    
    # Verificar estado del sistema
    try:
        status_response = requests.get(f"{API_BASE_URL}/api/chat/status", timeout=5)
        if status_response.status_code == 200:
            status_data = status_response.json()
            vector_db = status_data.get("vector_database", {})
            total_chunks = vector_db.get("total_chunks", 0)
            
            if total_chunks == 0:
                st.warning("‚ö†Ô∏è No hay documentos cargados. Ve a 'Subir Documentos' primero.")
                return
            else:
                st.success(f"üìö {total_chunks} fragmentos de documentos disponibles")
        else:
            st.error("‚ùå No se puede conectar al sistema")
            return
    except Exception as e:
        st.error(f"‚ùå Error verificando estado: {str(e)}")
        return
    
    st.markdown("Compara diferentes aspectos o temas entre tus documentos usando IA.")
    
    # Configuraci√≥n de comparaci√≥n
    st.subheader("üîç Configurar Comparaci√≥n")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**üìÑ Primer conjunto de documentos:**")
        query1 = st.text_area(
            "Describe qu√© buscar en el primer grupo:",
            placeholder="Ej: metodolog√≠a de investigaci√≥n, conclusiones sobre X tema",
            height=100,
            help="Describe el tema o aspecto que quieres encontrar en el primer grupo de documentos"
        )
    
    with col2:
        st.markdown("**üìÑ Segundo conjunto de documentos:**")
        query2 = st.text_area(
            "Describe qu√© buscar en el segundo grupo:",
            placeholder="Ej: resultados experimentales, recomendaciones sobre Y tema",
            height=100,
            help="Describe el tema o aspecto que quieres encontrar en el segundo grupo de documentos"
        )
    
    # Configuraci√≥n adicional
    col1, col2 = st.columns(2)
    with col1:
        max_results = st.slider(
            "üìä Fragmentos por grupo:",
            min_value=1, max_value=5, value=3,
            help="N√∫mero m√°ximo de fragmentos relevantes por cada grupo"
        )
    
    with col2:
        comparison_focus = st.selectbox(
            "üéØ Enfoque de comparaci√≥n:",
            ["Similitudes y diferencias", "Solo similitudes", "Solo diferencias", "An√°lisis complementario"],
            help="Tipo de an√°lisis comparativo a realizar"
        )
    
    # Generar comparaci√≥n
    if st.button("‚öñÔ∏è Generar Comparaci√≥n", type="primary"):
        if not query1.strip() or not query2.strip():
            st.error("‚ùå Por favor, completa ambas descripciones de b√∫squeda")
            return
        
        with st.spinner("ü§ñ Analizando y comparando documentos..."):
            try:
                comparison_request = {
                    "doc1_query": query1,
                    "doc2_query": query2,
                    "max_results": max_results
                }
                
                response = requests.post(
                    f"{API_BASE_URL}/api/compare",
                    json=comparison_request,
                    timeout=60
                )
                
                if response.status_code == 200:
                    comparison_response = response.json()
                    
                    if comparison_response.get("success", False):
                        st.success("‚úÖ Comparaci√≥n generada exitosamente")
                        
                        # Mostrar estad√≠sticas de la b√∫squeda
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.metric("üìÑ Fragmentos Grupo 1", comparison_response.get("doc1_fragments", 0))
                        with col2:
                            st.metric("ÔøΩ Fragmentos Grupo 2", comparison_response.get("doc2_fragments", 0))
                        with col3:
                            st.metric("üîß M√©todo", comparison_response.get("method", "unknown"))
                        
                        # Mostrar consultas utilizadas
                        with st.expander("üîç Consultas utilizadas"):
                            queries = comparison_response.get("queries", {})
                            st.write(f"**Grupo 1:** {queries.get('doc1_query', 'N/A')}")
                            st.write(f"**Grupo 2:** {queries.get('doc2_query', 'N/A')}")
                        
                        # Mostrar comparaci√≥n
                        st.subheader("üìä An√°lisis Comparativo")
                        comparison_text = comparison_response.get("comparison", "")
                        st.markdown(comparison_text)
                        
                        # Opci√≥n de descarga
                        col1, col2 = st.columns(2)
                        with col1:
                            st.download_button(
                                label="‚¨áÔ∏è Descargar Comparaci√≥n",
                                data=comparison_text,
                                file_name="comparacion_documentos.txt",
                                mime="text/plain"
                            )
                        
                        with col2:
                            # Descargar datos completos como JSON
                            comparison_data = {
                                "queries": queries,
                                "statistics": {
                                    "doc1_fragments": comparison_response.get("doc1_fragments", 0),
                                    "doc2_fragments": comparison_response.get("doc2_fragments", 0),
                                    "method": comparison_response.get("method", "unknown")
                                },
                                "comparison": comparison_text
                            }
                            
                            st.download_button(
                                label="üìã Descargar Datos JSON",
                                data=json.dumps(comparison_data, indent=2, ensure_ascii=False),
                                file_name="comparacion_completa.json",
                                mime="application/json"
                            )
                        
                    else:
                        st.error(f"‚ùå Error generando comparaci√≥n: {comparison_response.get('error', 'Error desconocido')}")
                else:
                    st.error(f"‚ùå Error del servidor: {response.status_code}")
                    
            except requests.exceptions.Timeout:
                st.error("‚è±Ô∏è Tiempo de espera agotado. La comparaci√≥n puede estar tardando m√°s de lo esperado.")
            except Exception as e:
                st.error(f"‚ùå Error inesperado: {str(e)}")
    
    # Ejemplos de comparaci√≥n
    with st.expander("üí° Ejemplos de comparaciones"):
        st.markdown("""
        **Comparaci√≥n metodol√≥gica:**
        - Grupo 1: "metodolog√≠a cuantitativa"
        - Grupo 2: "metodolog√≠a cualitativa"
        
        **Comparaci√≥n temporal:**
        - Grupo 1: "resultados del primer trimestre"
        - Grupo 2: "resultados del segundo trimestre"
        
        **Comparaci√≥n conceptual:**
        - Grupo 1: "ventajas del enfoque A"
        - Grupo 2: "ventajas del enfoque B"
        
        **Comparaci√≥n de perspectivas:**
        - Grupo 1: "opini√≥n de expertos"
        - Grupo 2: "datos estad√≠sticos"
        """)
    
    with st.expander("üîß C√≥mo funciona la comparaci√≥n"):
        st.markdown("""
        1. **B√∫squeda dirigida**: Se buscan fragmentos relevantes para cada consulta
        2. **Agrupaci√≥n**: Los fragmentos se organizan en dos grupos basados en las consultas
        3. **An√°lisis con IA**: El modelo de lenguaje analiza ambos grupos
        4. **Comparaci√≥n estructurada**: Se genera un an√°lisis que incluye:
           - Similitudes encontradas
           - Diferencias clave identificadas
           - Aspectos complementarios
           - Conclusiones del an√°lisis comparativo
        """)
    
    # Consejos de uso
    with st.expander("üìù Consejos para mejores comparaciones"):
        st.markdown("""
        **Para obtener mejores resultados:**
        - S√© espec√≠fico en las descripciones de b√∫squeda
        - Usa t√©rminos clave relevantes de tus documentos
        - Considera diferentes perspectivas del mismo tema
        - Experimenta con diferentes enfoques de comparaci√≥n
        
        **Ejemplos de t√©rminos efectivos:**
        - Nombres de metodolog√≠as, teor√≠as o conceptos espec√≠ficos
        - Fechas, per√≠odos o fases temporales
        - Tipos de datos o evidencia
        - Diferentes stakeholders o perspectivas
        """)

def advanced_summary_page():
    """P√°gina para resumen avanzado de documentos"""
    st.header("üìä Resumen Avanzado de Documentos")
    
    # Verificar tipos de resumen disponibles
    try:
        types_response = requests.get(f"{API_BASE_URL}/api/chat/summarize/types", timeout=5)
        if types_response.status_code == 200:
            types_data = types_response.json()
            summary_types = types_data.get("summary_types", {})
        else:
            summary_types = {}
    except:
        summary_types = {}
    
    # Configuraci√≥n del resumen
    st.subheader("‚öôÔ∏è Configuraci√≥n del Resumen")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Selecci√≥n de tipo de resumen
        summary_type = st.selectbox(
            "Tipo de Resumen:",
            options=list(summary_types.keys()) if summary_types else ["comprehensive", "executive", "technical", "bullet_points"],
            format_func=lambda x: summary_types.get(x, {}).get("name", x.title()) if summary_types else x.title(),
            help="Selecciona el tipo de resumen que mejor se adapte a tus necesidades"
        )
        
        # Mostrar descripci√≥n del tipo seleccionado
        if summary_types and summary_type in summary_types:
            type_info = summary_types[summary_type]
            st.info(f"**{type_info.get('name', '')}**: {type_info.get('description', '')}")
            st.markdown(f"*Recomendado para: {type_info.get('recommended_for', '')}*")
    
    with col2:
        # Configuraciones adicionales
        max_tokens = st.slider(
            "Longitud m√°xima (tokens):",
            min_value=200,
            max_value=1500,
            value=800,
            step=50,
            help="Controla la longitud del resumen generado"
        )
        
        # Opci√≥n para documentos espec√≠ficos (placeholder)
        st.markdown("**Documentos a resumir:**")
        all_documents = st.checkbox("Todos los documentos en la base de datos", value=True, key="advanced_all_documents")
        
        if not all_documents:
            st.info("üí° Funci√≥n de selecci√≥n espec√≠fica de documentos pr√≥ximamente")
    
    # Bot√≥n para generar resumen
    if st.button("üìù Generar Resumen Avanzado", type="primary"):
        with st.spinner(f"Generando resumen {summary_type}... Esto puede tomar unos momentos."):
            try:
                # Preparar request
                request_data = {
                    "summary_type": summary_type,
                    "max_tokens": max_tokens
                }
                
                # Si no se seleccionan todos los documentos, se puede agregar document_ids
                if not all_documents:
                    request_data["document_ids"] = []  # Lista vac√≠a por ahora
                
                # Hacer request al endpoint avanzado
                response = requests.post(
                    f"{API_BASE_URL}/api/chat/summarize/advanced",
                    json=request_data,
                    timeout=30
                )
                
                if response.status_code == 200:
                    result = response.json()
                    
                    if result.get("success", False):
                        st.success("‚úÖ Resumen generado exitosamente!")
                        
                        # Mostrar estad√≠sticas del resumen
                        col1, col2, col3, col4 = st.columns(4)
                        with col1:
                            st.metric("üìÑ Documentos", result.get("documents_processed", 0))
                        with col2:
                            st.metric("üî§ Tokens usados", result.get("tokens_used", 0))
                        with col3:
                            st.metric("ü§ñ M√©todo", result.get("method", "Unknown").replace("_", " ").title())
                        with col4:
                            st.metric("üìã Tipo", result.get("summary_type", "").title())
                        
                        # Mostrar el resumen
                        st.subheader(f"üìã Resumen {summary_type.title()}")
                        summary_text = result.get("summary", "")
                        st.markdown(summary_text)
                        
                        # Bot√≥n para descargar
                        if summary_text:
                            st.download_button(
                                label="üíæ Descargar Resumen",
                                data=summary_text,
                                file_name=f"resumen_{summary_type}_{result.get('documents_processed', 0)}_docs.txt",
                                mime="text/plain"
                            )
                        
                        # Informaci√≥n adicional
                        if result.get("model_used") and result.get("model_used") != "unknown":
                            st.info(f"ü§ñ Modelo utilizado: {result.get('model_used')}")
                    
                    else:
                        st.error(f"‚ùå Error generando resumen: {result.get('error', 'Error desconocido')}")
                
                else:
                    st.error(f"‚ùå Error del servidor: {response.status_code}")
                    
            except requests.exceptions.Timeout:
                st.error("‚è∞ Timeout: El resumen est√° tomando m√°s tiempo del esperado")
            except requests.exceptions.ConnectionError:
                st.error("üîå Error de conexi√≥n con el backend")
            except Exception as e:
                st.error(f"‚ùå Error inesperado: {str(e)}")
    
    # Informaci√≥n sobre tipos de resumen
    if summary_types:
        st.subheader("üìñ Informaci√≥n sobre Tipos de Resumen")
        for type_key, type_info in summary_types.items():
            with st.expander(f"üìã {type_info.get('name', type_key.title())}"):
                st.markdown(f"**Descripci√≥n:** {type_info.get('description', '')}")
                st.markdown(f"**Recomendado para:** {type_info.get('recommended_for', '')}")
    
    # Informaci√≥n sobre funcionalidades
    with st.expander("‚ÑπÔ∏è Caracter√≠sticas del Resumen Avanzado"):
        features = {
            "ü§ñ IA Avanzada": "Usa Llama local cuando est√° disponible para res√∫menes sofisticados",
            "üîÑ Fallback Inteligente": "Sistema de respaldo con resumen extractivo si no hay LLM",
            "üìö Multi-documento": "Puede resumir m√∫ltiples documentos simult√°neamente",
            "üéØ Tipos Especializados": "Diferentes tipos de resumen para diferentes audiencias",
            "‚öôÔ∏è Configurable": "Control sobre longitud y enfoque del resumen"
        }
        
        for feature, description in features.items():
            st.markdown(f"**{feature}**: {description}")

def topic_classification_page():
    """P√°gina para clasificaci√≥n de temas de documentos"""
    st.header("üè∑Ô∏è Clasificaci√≥n de Temas")
    
    # Obtener etiquetas disponibles
    try:
        labels_response = requests.get(f"{API_BASE_URL}/api/chat/classify/labels", timeout=5)
        if labels_response.status_code == 200:
            labels_data = labels_response.json()
            default_labels = labels_data.get("default_labels", [])
            label_categories = labels_data.get("label_categories", {})
        else:
            default_labels = []
            label_categories = {}
    except:
        default_labels = ["tecnolog√≠a", "ciencia", "negocios", "salud", "educaci√≥n"]
        label_categories = {}
    
    # Configuraci√≥n de clasificaci√≥n
    st.subheader("‚öôÔ∏è Configuraci√≥n de Clasificaci√≥n")
    
    # Pesta√±as para diferentes opciones
    tab1, tab2, tab3 = st.tabs(["üè∑Ô∏è Clasificaci√≥n por Colecci√≥n", "üìÑ Documento Individual", "üìä An√°lisis de Insights"])
    
    with tab1:
        st.subheader("üìö Clasificar Colecci√≥n de Documentos")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Usar etiquetas por defecto o personalizadas
            use_custom_labels = st.checkbox("Usar etiquetas personalizadas", value=False, key="comparison_custom_labels")
            
            if use_custom_labels:
                st.markdown("**Etiquetas personalizadas:**")
                custom_labels_input = st.text_area(
                    "Ingresa etiquetas separadas por comas:",
                    value=", ".join(default_labels[:5]),
                    help="Ejemplo: tecnolog√≠a, medicina, educaci√≥n, finanzas"
                )
                labels_to_use = [label.strip() for label in custom_labels_input.split(",") if label.strip()]
            else:
                labels_to_use = default_labels
                st.markdown("**Etiquetas por defecto:**")
                st.write(", ".join(labels_to_use))
        
        with col2:
            # Configuraciones avanzadas
            confidence_threshold = st.slider(
                "Umbral de confianza:",
                min_value=0.1,
                max_value=0.9,
                value=0.3,
                step=0.1,
                help="Clasificaciones con confianza menor ser√°n marcadas como 'unknown'"
            )
            
            # Selecci√≥n de documentos (placeholder)
            st.markdown("**Documentos a clasificar:**")
            all_docs_classify = st.checkbox("Todos los documentos", value=True, key="classify_all")
            
            if not all_docs_classify:
                st.info("üí° Selecci√≥n espec√≠fica pr√≥ximamente")
        
        # Bot√≥n para clasificar
        if st.button("üè∑Ô∏è Clasificar Documentos", type="primary", key="classify_collection"):
            with st.spinner("Clasificando documentos... Esto puede tomar unos momentos."):
                try:
                    request_data = {
                        "confidence_threshold": confidence_threshold
                    }
                    
                    if use_custom_labels and labels_to_use:
                        request_data["custom_labels"] = labels_to_use
                    
                    response = requests.post(
                        f"{API_BASE_URL}/api/chat/classify/topics",
                        json=request_data,
                        timeout=45
                    )
                    
                    if response.status_code == 200:
                        result = response.json()
                        
                        if result.get("success", False):
                            st.success("‚úÖ Clasificaci√≥n completada!")
                            
                            # Estad√≠sticas generales
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.metric("üìÑ Documentos", result.get("total_documents", 0))
                            with col2:
                                st.metric("üè∑Ô∏è Temas encontrados", len([t for t in result.get("topic_statistics", {}).values() if t > 0]))
                            with col3:
                                st.metric("üéØ M√©todo", result.get("method", "unknown").replace("_", " ").title())
                            
                            # Gr√°fico de distribuci√≥n de temas
                            topic_stats = result.get("topic_statistics", {})
                            if topic_stats:
                                st.subheader("üìä Distribuci√≥n de Temas")
                                
                                # Preparar datos para gr√°fico
                                topics = list(topic_stats.keys())
                                counts = list(topic_stats.values())
                                
                                # Mostrar en columnas
                                cols = st.columns(min(4, len([c for c in counts if c > 0])))
                                col_idx = 0
                                for topic, count in zip(topics, counts):
                                    if count > 0:
                                        with cols[col_idx % len(cols)]:
                                            st.metric(topic.title(), count)
                                        col_idx += 1
                            
                            # Temas dominantes
                            dominant_topics = result.get("dominant_topics", [])
                            if dominant_topics:
                                st.subheader("üèÜ Temas Dominantes")
                                for i, (topic, count) in enumerate(dominant_topics[:5]):
                                    percentage = (count / result.get("total_documents", 1)) * 100
                                    st.write(f"**{i+1}. {topic.title()}**: {count} documentos ({percentage:.1f}%)")
                            
                            # Clasificaciones individuales
                            classifications = result.get("classification_results", {}).get("classifications", [])
                            if classifications:
                                st.subheader("üìã Clasificaciones Individuales")
                                
                                # Filtros
                                show_all = st.checkbox("Mostrar todos los documentos", value=False, key="comparison_show_all")
                                if not show_all:
                                    min_confidence = st.slider("Confianza m√≠nima a mostrar:", 0.0, 1.0, 0.3, 0.1)
                                    filtered_classifications = [c for c in classifications if c.get("confidence", 0) >= min_confidence]
                                else:
                                    filtered_classifications = classifications
                                
                                for doc_class in filtered_classifications[:10]:  # Mostrar primeros 10
                                    with st.expander(f"üìÑ {doc_class.get('document', 'Documento')} - {doc_class.get('primary_topic', 'unknown').title()}"):
                                        st.write(f"**Tema principal:** {doc_class.get('primary_topic', 'unknown').title()}")
                                        st.write(f"**Confianza:** {doc_class.get('confidence', 0):.2f}")
                                        
                                        # Mostrar todos los scores si est√°n disponibles
                                        all_scores = doc_class.get('all_scores', {})
                                        if all_scores:
                                            st.write("**Puntuaciones por tema:**")
                                            for topic, score in sorted(all_scores.items(), key=lambda x: x[1], reverse=True):
                                                if score > 0.1:  # Solo mostrar scores significativos
                                                    st.write(f"  - {topic.title()}: {score:.3f}")
                            
                            # Insights si est√°n disponibles
                            insights = result.get("insights", {})
                            if insights:
                                st.subheader("üí° Insights de la Colecci√≥n")
                                
                                collection_profile = insights.get("collection_profile", {})
                                if collection_profile:
                                    st.write(f"**Enfoque principal:** {collection_profile.get('primary_focus', 'Desconocido').title()}")
                                    st.write(f"**Porcentaje de enfoque:** {collection_profile.get('focus_percentage', 0):.1f}%")
                                    
                                    if collection_profile.get('is_specialized'):
                                        st.info("üìö Esta es una colecci√≥n especializada")
                                    if collection_profile.get('is_diverse'):
                                        st.info("üåà Esta colecci√≥n tiene buena diversidad tem√°tica")
                                
                                diversity_analysis = insights.get("diversity_analysis", {})
                                if diversity_analysis:
                                    st.write(f"**Clasificaci√≥n de diversidad:** {diversity_analysis.get('classification', 'Desconocida')}")
                                    st.write(f"**Puntuaci√≥n de diversidad:** {diversity_analysis.get('diversity_score', 0):.1f}%")
                        
                        else:
                            st.error(f"‚ùå Error en clasificaci√≥n: {result.get('error', 'Error desconocido')}")
                    
                    else:
                        st.error(f"‚ùå Error del servidor: {response.status_code}")
                        
                except requests.exceptions.Timeout:
                    st.error("‚è∞ Timeout: La clasificaci√≥n est√° tomando m√°s tiempo del esperado")
                except requests.exceptions.ConnectionError:
                    st.error("üîå Error de conexi√≥n con el backend")
                except Exception as e:
                    st.error(f"‚ùå Error inesperado: {str(e)}")
    
    with tab2:
        st.subheader("üìÑ Clasificar Documento Individual")
        
        # Entrada de texto
        document_content = st.text_area(
            "Ingresa el contenido del documento:",
            height=200,
            placeholder="Pega aqu√≠ el texto que deseas clasificar..."
        )
        
        if document_content.strip():
            col1, col2 = st.columns(2)
            
            with col1:
                # Configuraci√≥n para documento individual
                use_custom_single = st.checkbox("Etiquetas personalizadas", value=False, key="single_custom")
                if use_custom_single:
                    custom_single_labels = st.text_input(
                        "Etiquetas (separadas por comas):",
                        value=", ".join(default_labels[:5])
                    )
                    single_labels = [label.strip() for label in custom_single_labels.split(",") if label.strip()]
                else:
                    single_labels = default_labels
            
            with col2:
                single_threshold = st.slider(
                    "Umbral de confianza:",
                    min_value=0.1,
                    max_value=0.9,
                    value=0.3,
                    step=0.1,
                    key="single_threshold"
                )
            
            if st.button("üè∑Ô∏è Clasificar Texto", type="primary", key="classify_single"):
                with st.spinner("Clasificando contenido..."):
                    try:
                        params = {
                            "content": document_content,
                            "confidence_threshold": single_threshold
                        }
                        
                        if use_custom_single and single_labels:
                            params["custom_labels"] = single_labels
                        
                        response = requests.post(
                            f"{API_BASE_URL}/api/chat/classify/single",
                            params=params,
                            timeout=15
                        )
                        
                        if response.status_code == 200:
                            result = response.json()
                            
                            if result.get("success", False):
                                st.success("‚úÖ Texto clasificado!")
                                
                                # Resultado principal
                                col1, col2, col3 = st.columns(3)
                                with col1:
                                    st.metric("üè∑Ô∏è Tema principal", result.get("primary_topic", "unknown").title())
                                with col2:
                                    st.metric("üéØ Confianza", f"{result.get('confidence', 0):.2f}")
                                with col3:
                                    st.metric("üìè Caracteres", result.get("content_length", 0))
                                
                                # Raz√≥n de la clasificaci√≥n
                                if result.get("reason"):
                                    st.info(f"üí≠ **Raz√≥n:** {result.get('reason')}")
                                
                                # Puntuaciones detalladas
                                scores = result.get("scores", {})
                                if scores:
                                    st.subheader("üìä Puntuaciones por Tema")
                                    sorted_scores = sorted(scores.items(), key=lambda x: x[1], reverse=True)
                                    
                                    for topic, score in sorted_scores:
                                        if score > 0.05:  # Solo mostrar scores relevantes
                                            progress_val = min(score, 1.0)
                                            st.write(f"**{topic.title()}**")
                                            st.progress(progress_val)
                                            st.write(f"Puntuaci√≥n: {score:.3f}")
                                            st.write("")
                            
                            else:
                                st.error(f"‚ùå Error: {result.get('error', 'Error desconocido')}")
                        
                        else:
                            st.error(f"‚ùå Error del servidor: {response.status_code}")
                            
                    except Exception as e:
                        st.error(f"‚ùå Error: {str(e)}")
    
    with tab3:
        st.subheader("üìä An√°lisis de Insights")
        st.info("üí° Ejecuta primero una clasificaci√≥n por colecci√≥n para ver insights detallados")
        
        # Informaci√≥n sobre qu√© insights se pueden obtener
        with st.expander("üîç ¬øQu√© insights puedes obtener?"):
            st.markdown("""
            **Perfil de la Colecci√≥n:**
            - Tema principal y su porcentaje de dominancia
            - Si la colecci√≥n es especializada o diversa
            - Distribuci√≥n tem√°tica general
            
            **An√°lisis de Diversidad:**
            - Puntuaci√≥n de diversidad (0-100%)
            - Clasificaci√≥n cualitativa de la diversidad
            - N√∫mero de temas presentes
            
            **Recomendaciones:**
            - Sugerencias basadas en la distribuci√≥n tem√°tica
            - Identificaci√≥n de posibles mejoras
            - Orientaci√≥n para an√°lisis adicionales
            """)
    
    # Informaci√≥n sobre categor√≠as de etiquetas
    if label_categories:
        st.subheader("üìÇ Categor√≠as de Etiquetas Disponibles")
        for category, labels in label_categories.items():
            with st.expander(f"üìÅ {category.title()}"):
                st.write(", ".join(labels))
    
    # Informaci√≥n sobre funcionalidades
    with st.expander("‚ÑπÔ∏è Caracter√≠sticas de Clasificaci√≥n"):
        st.markdown("""
        **ü§ñ M√©todos de Clasificaci√≥n:**
        - **LLM Local**: Usa Llama para clasificaci√≥n inteligente cuando est√° disponible
        - **Palabras Clave**: Sistema de respaldo basado en coincidencias de palabras clave
        - **HuggingFace**: Zero-shot classification (en desarrollo futuro)
        
        **üéØ Caracter√≠sticas:**
        - Etiquetas personalizables para dominios espec√≠ficos
        - Control de umbral de confianza
        - An√°lisis de insights autom√°tico
        - Estad√≠sticas detalladas de distribuci√≥n
        - Clasificaci√≥n individual o por lotes
        """)

if __name__ == "__main__":
    main()
